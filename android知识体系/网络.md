# Https

## Get和post的区别

GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 

GET产生一个TCP数据包；POST产生两个TCP数据包。

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

## Http2.0 相对于 Http1.x 区别

- **二进制格式**：http1.x 是文本协议，而 http2.0 是二进制以帧为基本单位，是一个二进制协议，一帧中除了包含数据外同时还包含该帧的标识：Stream Identifier，即标识了该帧属于哪个 request,使得网络传输变得十分灵活。
- **多路复用**：多个请求共用一个TCP连接，多个请求可以同时在这个 TCP 连接上并发，一个是解决了建立多个 TCP 连接的消耗问题，一个也解决了效率的问题。
- **header 压缩**：主要是通过压缩 header 来减少请求的大小，减少流量消耗，提高效率。
- **支持服务端推送**

**Http3**

基于[QUIC](https://www.baidu.com/s?wd=QUIC&rsv_idx=2&tn=baiduhome_pg&usm=2&ie=utf-8&rsv_pq=fd1bfd62000fe244&oq=http3.0和2.0区别&rsv_t=0b5fNE4yeD2N1t7q26CPcaWSdbX8Z6gw7bb5DDRIYTNwzGSmDfEO6SRS6Qcev4z4%2Bu9V&rsv_dl=re_dqa_generate&sa=re_dqa_generate)协议，QUIC是一种基于[UDP](https://www.baidu.com/s?wd=UDP&rsv_idx=2&tn=baiduhome_pg&usm=2&ie=utf-8&rsv_pq=fd1bfd62000fe244&oq=http3.0和2.0区别&rsv_t=0b5fNE4yeD2N1t7q26CPcaWSdbX8Z6gw7bb5DDRIYTNwzGSmDfEO6SRS6Qcev4z4%2Bu9V&rsv_dl=re_dqa_generate&sa=re_dqa_generate)的传输层协议，通过减少连接建立时间和改进丢包处理机制，解决了TCP的队头阻塞问题。QUIC采用零往返时间握手和单往返时间握手，大大减少了连接建立时间

- 解决了头部阻塞问题
- 缩短建立连接的时间

[详解https是如何确保安全的](https://www.jianshu.com/p/304674bd0618)

[详解HTTP3.0协议和QUIC协议](https://blog.csdn.net/Rookie_CEO/article/details/141604175)

## Https过程

1. 在使用HTTPS是需要保证服务端配置正确了对应的安全证书
2. 客户端发送请求到服务端
3. 服务端返回公钥和证书到客户端
4. 客户端接收后会验证证书的安全性,如果通过则会随机生成一个随机数,用公钥对其加密,发送到服务端
5. 服务端接受到这个加密后的随机数后会用私钥对其解密得到真正的随机数,随后用这个随机数当做私钥对需要发送的数据进行对称加密
6. 客户端在接收到加密后的数据使用私钥(即生成的随机值)对数据进行解密并且解析数据呈现结果给客户
7. SSL加密建立

## 如何保证通信安全

非对称加密
数字证书
数字签名

如何验证证书的合法性

生成数字签名一同放倒证书里。当客户端收到服务器发送的证书时i，可以通过证书中的hash算法对证书信息签名的得到信息摘要，然后使用CA机构的公钥对原证书中的签名信息解密，如果解密后的“信息摘要”和自签名得到的一致，则说明没问题

1. **加密传输**：HTTPS使用TLS/SSL协议对数据进行加密，确保传输过程中即使被截获也无法被直接解读。
2. **证书验证**：服务器需提供由可信证书颁发机构（CA）签发的数字证书，客户端会验证证书的有效性，防止中间人攻击。
3. **防篡改与伪装**：通过数字签名和散列函数，确保数据完整性和通信双方身份的真实性

## App如何防止抓包

1. **禁用代理**：通过代码禁止使用代理（如OkHttp设置`Proxy.NO_PROXY`），使流量不经过抓包工具。

2. **SSL Pinning（证书绑定）** ：将服务器证书或公钥硬编码到APP中，仅信任指定证书，即使安装Charles证书也无法解密。

3. **数据二次加密**：对传输内容额外加密，即使被抓包也显示为乱码，需逆向APP解密算法才能解析。

4. **混淆与加固**：使用代码混淆、CNAME切换域名等技术增加逆向难度

5. #### Sign签名



Charles能抓https请求么？能抓的话那安全性在哪？

**Charles的中间人代理原理**
Charles通过以下步骤实现HTTPS抓包：

- 拦截客户端请求，伪造服务器证书发送给客户端；
- 客户端信任Charles证书后，生成对称加密密钥并用Charles公钥加密；
- Charles解密密钥，再用服务器公钥加密后转发给服务器。
  此过程依赖**客户端主动信任Charles的证书**，否则连接会被中止



[移动端防抓包方案设计和实践

[深入理解Https如何保证通信安全](https://www.cnblogs.com/chenxf1117/p/15127479.html)

# TCP

TCP 的面向连接（三次握手、四次挥手）、基于字节流、全双工、可靠性（流量控制、拥塞控制、重传机制等）。TCP 的缺陷（队头阻塞），以及 HTTP3 的怎么解决的？TIME_WAIT 状态的理解？

流量控制：如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓**流量控制**就是让发送方的发送速率不要太快，要让接收方来得及接收。

- 滑动窗口机制

拥塞控制：

​	发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口



**三次握手的原因**

- 第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

**四次挥手的原因**

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据。

**长链接实现**

- **引入必要的依赖**：如果是使用第三方库或者框架，首先要在项目中添加相应的依赖。
- **权限设置**：确保在`AndroidManifest.xml`文件中声明了互联网访问权限。
- **创建连接**：根据选择的技术栈，创建到服务器的连接。例如，使用Socket时，需指定服务器IP地址和端口号；使用WebSocket时，则需指定WebSocket URL。
- **处理消息**：定义如何处理接收到的消息以及如何向服务器发送消息。
- **维护连接**：实现心跳机制以维持连接活跃，防止由于长时间无活动导致的连接断开。
- **错误处理与重连逻辑**：设计合理的错误处理机制，当连接丢失时能够自动尝试重新连接。

[[计算机网络【七】：可靠传输的实现](http://blog.chinaunix.net/uid-26275986-id-4109679.html)](http://blog.chinaunix.net/uid-26275986-id-4109679.html)

# 其他

- Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。
- Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式

长连接的实现：心跳机制，应用层协议大多都有HeartBeat机制，通常是客户端每隔一小段时间向服务器发送一个数据包，通知服务器自己仍然在线。

[面试官的这份HTTP灵魂追问你Hold住吗？](https://juejin.cn/post/6877362691350986766)

[网络面试题](https://github.com/JsonChao/Awesome-Android-Interview/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98.md)
