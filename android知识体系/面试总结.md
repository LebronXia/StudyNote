雅乐：

1. java和kotlin泛型
2. 线程池核心线程的工作原理
3. 协程，父域和子域，创建方式，协程的写法
4. by委托的写法
5. ::的原理
   1. **双冒号 `::`** 是 Kotlin 的成员引用操作符，用于获取属性或方法的反射引用。
6. 什么时候要重写onLayout
   1. 在父布局中确定位置
7. 协程中Async会返回什么
   1. *`async` 代码块在协程被创建时立即开始执行**，与 `await()` 的调用无关。
   2. `await()` 仅用于挂起当前协程，等待结果返回。
   3. `async` 返回的 `Deferred<T>` 是协程中处理 **带返回值的异步任务** 的核心对象
8. flow的zip和contact区别，以及buffer满的时候处理方法
   1. Contact将 **两个 Flow 按顺序连接**，先发射第一个 Flow 的所有元素，再发射第二个 Flow 的元素。
   2. Zip将 **两个 Flow 的元素按顺序一一配对**，当两个 Flow 的对应位置元素都到达时，触发合并操作。
   3. **`SharedFlow` 缓冲区溢出策略**：根据业务需求选择 `SUSPEND`、`DROP_OLDEST` 或 `DROP_LATEST`，平衡数据完整性和实时性。

10. 线程stop和Interrupt区别

    1. Interrupt:
    2. **协作式终止**：通过设置中断标志（`interrupt()`）请求线程终止，线程自行决定如何响应。
    3. **安全处理**：线程可检测中断状态并优雅退出，确保资源清理。
    4. Stop：强制终止线程

11. 类型擦除是怎么实现的

12. 高阶函数 inline crossInline

    1. 若要在 `inline` 函数中返回传入的函数参数，**必须使用 `noinline` 修饰该参数**，否则编译器报错
    2. crossInline:修饰 `inline` 函数中的 **某个 Lambda 参数**，要求该 Lambda **必须被内联**，但禁止其内部使用非局部返回（即不允许 `return`）
    3. inLIne:修饰高阶函数，表示该函数及其 **所有 Lambda 参数** 的代码会被直接复制到调用处（内联）

    Popo8888